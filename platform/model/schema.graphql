## NOTE: This schema was generated by Graphback and should not be changed manually

enum ActionStatus {
  CREATED
  ASSIGNED
  COMPLETED
}

interface Address {
  address1: String
  address2: String
  city: String
  postcode: Int
}

input BooleanInput {
  ne: Boolean
  eq: Boolean
}

input CreateDistributionCentreInput {
  id: ID
  name: String
  address1: String
  address2: String
  city: String
  postcode: Int
  lat: Float
  long: Float
}

input CreateProductInput {
  id: ID
  label: String!
  description: String
  distributionCentreId: ID
}

input CreateRecipientInput {
  id: ID
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  postcode: Int
  city: String
  createdAt: DateTime
  prefferedProducts: String
}

input CreateVolunteerActionInput {
  id: ID
  title: String!
  description: String
  status: ActionStatus
  createdAt: DateTime
  distributionCentreId: ID
  volunteerId: ID
  recipientId: ID
}

input CreateVolunteerActionProductInput {
  id: ID
  productId: ID
  volunteerActionId: ID
}

input CreateVolunteerInput {
  id: ID
  firstName: String
  lastName: String
  email: String
  username: String!
  address1: String
  address2: String
  city: String
  postcode: Int
  dateOfBirth: DateTime
  canDeliver: Boolean
}

scalar DateTime

"""
@model
@crud.delete: false
"""
type DistributionCentre implements Address {
  id: ID!
  name: String
  address1: String
  address2: String
  city: String
  postcode: Int
  lat: Float
  long: Float

  """@oneToMany field: 'distributionCentre', key: 'distributionCentreId'"""
  products(filter: ProductFilter): [Product]

  """@oneToMany field: 'distributionCentre', key: 'distributionCentreId'"""
  actions(filter: VolunteerActionFilter): [VolunteerAction]!
}

input DistributionCentreFilter {
  id: IDInput
  name: StringInput
  address1: StringInput
  address2: StringInput
  city: StringInput
  postcode: IntInput
  lat: FloatInput
  long: FloatInput
  and: [DistributionCentreFilter]
  or: [DistributionCentreFilter]
  not: DistributionCentreFilter
}

type DistributionCentreResultList {
  items: [DistributionCentre]!
  offset: Int
  limit: Int
  count: Int
}

input FloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  in: [Float]
  between: [Float]
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID]
  contains: ID
  startsWith: ID
  endsWith: ID
}

input IntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int]
  between: [Int]
}

input MutateDistributionCentreInput {
  id: ID!
  name: String
  address1: String
  address2: String
  city: String
  postcode: Int
  lat: Float
  long: Float
}

input MutateProductInput {
  id: ID!
  label: String
  description: String
  distributionCentreId: ID
}

input MutateRecipientInput {
  id: ID!
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  postcode: Int
  city: String
  createdAt: DateTime
  prefferedProducts: String
}

input MutateVolunteerActionInput {
  id: ID!
  title: String
  description: String
  status: ActionStatus
  createdAt: DateTime
  distributionCentreId: ID
  volunteerId: ID
  recipientId: ID
}

input MutateVolunteerInput {
  id: ID!
  firstName: String
  lastName: String
  email: String
  username: String
  address1: String
  address2: String
  city: String
  postcode: Int
  dateOfBirth: DateTime
  canDeliver: Boolean
}

type Mutation {
  createDistributionCentre(input: CreateDistributionCentreInput!): DistributionCentre!
  updateDistributionCentre(input: MutateDistributionCentreInput!): DistributionCentre!
  createProduct(input: CreateProductInput!): Product!
  updateProduct(input: MutateProductInput!): Product!
  createVolunteerActionProduct(input: CreateVolunteerActionProductInput!): VolunteerActionProduct!
  createVolunteer(input: CreateVolunteerInput!): Volunteer!
  updateVolunteer(input: MutateVolunteerInput!): Volunteer!
  createVolunteerAction(input: CreateVolunteerActionInput!): VolunteerAction!
  updateVolunteerAction(input: MutateVolunteerActionInput!): VolunteerAction!
  createRecipient(input: CreateRecipientInput!): Recipient!
  updateRecipient(input: MutateRecipientInput!): Recipient!
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum = ASC
}

input PageRequest {
  limit: Int
  offset: Int
}

"""
@model
@crud.delete: false
"""
type Product {
  id: ID!
  label: String!
  description: String

  """@manyToOne field: 'products', key: 'distributionCentreId'"""
  distributionCentre: DistributionCentre

  """@oneToMany field: 'product', key: 'productId'"""
  volunteerActionProducts(filter: VolunteerActionProductFilter): [VolunteerActionProduct]
}

input ProductFilter {
  id: IDInput
  label: StringInput
  description: StringInput
  distributionCentreId: IDInput
  and: [ProductFilter]
  or: [ProductFilter]
  not: ProductFilter
}

type ProductResultList {
  items: [Product]!
  offset: Int
  limit: Int
  count: Int
}

type Query {
  getDistributionCentre(id: ID!): DistributionCentre
  findDistributionCentres(filter: DistributionCentreFilter, page: PageRequest, orderBy: OrderByInput): DistributionCentreResultList!
  getProduct(id: ID!): Product
  findProducts(filter: ProductFilter, page: PageRequest, orderBy: OrderByInput): ProductResultList!
  getVolunteerActionProduct(id: ID!): VolunteerActionProduct
  findVolunteerActionProducts(filter: VolunteerActionProductFilter, page: PageRequest, orderBy: OrderByInput): VolunteerActionProductResultList!
  getVolunteer(id: ID!): Volunteer
  findVolunteers(filter: VolunteerFilter, page: PageRequest, orderBy: OrderByInput): VolunteerResultList!
  getVolunteerAction(id: ID!): VolunteerAction
  findVolunteerActions(filter: VolunteerActionFilter, page: PageRequest, orderBy: OrderByInput): VolunteerActionResultList!
  getRecipient(id: ID!): Recipient
  findRecipients(filter: RecipientFilter, page: PageRequest, orderBy: OrderByInput): RecipientResultList!
}

"""
@model
@crud.delete: false
"""
type Recipient implements Address {
  id: ID!
  firstName: String
  lastName: String
  phone: String
  address1: String
  address2: String
  postcode: Int
  city: String
  createdAt: DateTime

  """
  Comma separated list of preferrend products labels.
  Easier to create volunteer actions when knowing what one really needs. 
  """
  prefferedProducts: String

  """@oneToMany field: 'recipient', key: 'recipientId'"""
  actions(filter: VolunteerActionFilter): [VolunteerAction]
}

input RecipientFilter {
  id: IDInput
  firstName: StringInput
  lastName: StringInput
  phone: StringInput
  address1: StringInput
  address2: StringInput
  postcode: IntInput
  city: StringInput
  createdAt: StringInput
  prefferedProducts: StringInput
  and: [RecipientFilter]
  or: [RecipientFilter]
  not: RecipientFilter
}

type RecipientResultList {
  items: [Recipient]!
  offset: Int
  limit: Int
  count: Int
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String]
  contains: String
  startsWith: String
  endsWith: String
}

"""
@model
@crud.delete: false
"""
type Volunteer implements Address {
  id: ID!
  firstName: String
  lastName: String
  email: String
  username: String!
  address1: String
  address2: String
  city: String
  postcode: Int
  dateOfBirth: DateTime

  """
  This does not work for MongoDB - https://github.com/aerogear/graphback/issues/1241
  @db.default: false
  """
  canDeliver: Boolean

  """@oneToMany field: 'volunteer', key: 'volunteerId'"""
  actions(filter: VolunteerActionFilter): [VolunteerAction]
}

"""
Represents action that is assigned to volunteer
@model
"""
type VolunteerAction {
  id: ID!
  title: String!
  description: String
  status: ActionStatus
  createdAt: DateTime

  """@manyToOne field: 'actions', key: 'distributionCentreId'"""
  distributionCentre: DistributionCentre

  """@oneToMany field: 'volunteerAction', key: 'volunteerActionId'"""
  products(filter: VolunteerActionProductFilter): [VolunteerActionProduct]

  """@manyToOne field: 'actions', key: 'volunteerId'"""
  volunteer: Volunteer

  """@manyToOne field: 'actions', key: 'recipientId'"""
  recipient: Recipient
}

input VolunteerActionFilter {
  id: IDInput
  title: StringInput
  description: StringInput
  status: StringInput
  createdAt: StringInput
  distributionCentreId: IDInput
  volunteerId: IDInput
  recipientId: IDInput
  and: [VolunteerActionFilter]
  or: [VolunteerActionFilter]
  not: VolunteerActionFilter
}

"""
Represents a join model between a volunteer action and product

@model
@crud.create: true
@crud.update: false
@crud.delete: false
@crud.subCreate: false
@crud.subUpdate: false
@crud.subDelete: false
"""
type VolunteerActionProduct {
  id: ID!

  """@manyToOne field: 'volunteerActionProducts', key: 'productId'"""
  product: Product

  """@manyToOne field: 'products', key: 'volunteerActionId'"""
  volunteerAction: VolunteerAction
}

input VolunteerActionProductFilter {
  id: IDInput
  productId: IDInput
  volunteerActionId: IDInput
  and: [VolunteerActionProductFilter]
  or: [VolunteerActionProductFilter]
  not: VolunteerActionProductFilter
}

type VolunteerActionProductResultList {
  items: [VolunteerActionProduct]!
  offset: Int
  limit: Int
  count: Int
}

type VolunteerActionResultList {
  items: [VolunteerAction]!
  offset: Int
  limit: Int
  count: Int
}

input VolunteerFilter {
  id: IDInput
  firstName: StringInput
  lastName: StringInput
  email: StringInput
  username: StringInput
  address1: StringInput
  address2: StringInput
  city: StringInput
  postcode: IntInput
  dateOfBirth: StringInput
  canDeliver: BooleanInput
  and: [VolunteerFilter]
  or: [VolunteerFilter]
  not: VolunteerFilter
}

type VolunteerResultList {
  items: [Volunteer]!
  offset: Int
  limit: Int
  count: Int
}